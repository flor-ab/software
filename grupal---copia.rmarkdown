---
title: "Entrega grupal"
author: "Eli, Jazmín, Flor, Shengnan, Mariajo"
format:
  revealjs:
    theme: [style.scss]
    embed-resources: true
execute: 
  echo: true
---



## Paquetes necesarios

> Insertad aquí todos los paquetes vayáis necesitando



```{r}
rm(list = ls())
library(tidyverse)
library(glue)
library(forcats)
library(lubridate)
library(waffle)
```



---


## Entrega grupal

### Datos

La práctica se basará en los [**archivos de datos electorales**]{.hl-yellow} que se indican a continuación, recopilando datos sobre las elecciones al Congreso de los Diputados en España desde 2008 hasta la actualidad, así como encuestas, códigos de municipios y abreviaturas



```{r}
# NO TOQUES NADA
election_data <- read_csv(file = "./data/datos_elecciones_brutos.csv")
cod_mun <- read_csv(file = "./data/cod_mun.csv")
surveys <- read_csv(file = "./data/historical_surveys.csv")
abbrev <- read_csv(file = "./data/siglas.csv")
```




---

## Datos

-   `election_data`: archivo con las elecciones al congreso
-   `cod_mun`: archivo con los códigos y nombres de cada municipio
-   `abbrev`: siglas de cada partido
-   `surveys`: encuestas electorales desde 1982.

---

## Datos

-   `surveys`: encuestas electorales desde 1982.
    -   `type_survey`: tipo de encuesta (nacional, regional...)
    -   `date_elec`: fecha de las futuras elecciones
    -   `id_pollster`, `pollster`, `media`: id y nombre de la empresa encuestadora, así como medio que la encargó
    -   `field_date_from`, `field_date_to`: fechas de inicio y fin del trabajo de la encuesta
    -   `exit_poll`: ¿es una encuesta a pie de urna?
    -   `size`: tamaño muestral de la encuesta
    -   `turnout`: participación (estimación)

---

## Objetivos


El objetivo de la entrega es [**realizar un análisis de los datos electorales**]{.hl-green}, llevando a cabo la depuración, los resúmenes y los gráficos que consideres necesarios, tanto de los resultados como de la precisión de las encuestas electorales.

En concreto, debes trabajar únicamente en el **período de tiempo que incluye las elecciones desde 2008 hasta las últimas elecciones de 2019**

---

## Ítems obligatorios

1. Los datos deben ser convertidos a tidydata donde sea apropiado.

2. Debes incluir al menos un join entre tablas.

3. Los paquetes `{glue}`, `{forcats}` y `{lubridate}` deben ser utilizados en algún punto

4. Los siguientes elementos deben usarse al menos una vez: mutate, summarise, group_by (o su equivalente), case_when

5. Deberéis definir al menos una función (con más de 5 líneas de código)
    
---

## Ítems obligatorios

6. Contamos con muchos partidos que se presentan a las elecciones. Solo nos interesarán los siguientes partidos (cuidado: algunos tienen o tenían federaciones - sucursales - con otros nombres):

- PARTIDO SOCIALISTA OBRERO ESPAÑOL
- PARTIDO POPULAR
- CIUDADANOS
- PARTIDO NACIONALISTA VASCO
- BLOQUE NACIONALISTA GALLEGO
- UNIDAS PODEMOS - IU (Unidas Podemos, Unidos Podemos, Podemos, IU, Podem, y Ezker Batua).
- ESQUERRA REPUBLICANA DE CATALUNYA
- EH - BILDU (ahora son una coalición de partidos formada por lo que antes era Sortu, Eusko Alkartasuna, Aralar, Alternatiba).
- VOX

---

## Ítems obligatorios

7. Todo lo que no esté en alguno de los anteriores partidos debe ser correctamente reagrupado (y resumido) en `OTROS`

8.   Las siglas deben ser usadas en las visualizaciones (ideas en <https://r-graph-gallery.com/>).

9. Debes usar todos los archivos en algún momento.

10.  Debes descartar las encuestas que:

    -   se refieran a elecciones anteriores a 2008
    -   sean a pie de urna
    -   tamaño muestral desconocido o inferior a 500.
    -   tenga 1 día o menos de trabajo de campo.


---


## Depuración de datos



```{r}

names(election_data)

#Convertir a tidy data
eleccion_tidy <- election_data |> pivot_longer(cols = c(16:471), names_to = "partido", values_to = "votos", values_drop_na = TRUE)

eleccion_tidy |> distinct(codigo_distrito_electoral) #Sólo está el 0
eleccion_tidy |> distinct(vuelta) #Sólo vuelta 1 
eleccion_tidy |> distinct(tipo_eleccion) #Sólo tipo 02 --> nacionales
eleccion_tidy |> distinct(anno, mes) #Hubo 6 elecciones : 2008,2011,2015,2016,2019 (abril) y 2019 (noviembre)

#Depuración nombres de partidos

nombres_partidos <- c("PARTIDO SOCIALISTA OBRERO ESPAÑOL","PARTIDO POPULAR", "CIUDADANOS", "PARTIDO NACIONALISTA VASCO", "BLOQUE NACIONALISTA GALLEGO", "UNIDAS PODEMOS - IU", "ESQUERRA REPUBLICANA DE CATALUNYA",  "EH - BILDU", "VOX")

cambia_nombres <- function(partido, nombres) {
  partido_min <- str_to_lower(partido)
  nombres_min <- str_to_lower(nombres)
  
  if (str_detect(partido_min, c("sortu|eusko alkartasuna|aralar|alternatiba|euskal herria bildu"))) { #Añado el nombre completo de EH - Bildu y cambio a str_detect porque antes no captaba todo lo que debía (ej 2008, Victoria-Gasteiz EZKER BATUA-BERDEAK-ALTERNATIVA)
    return("EH - BILDU")
  }
  
  if (str_detect(partido_min, c("unidas podemos|unidos podemos|podemos|iu|podem|ezker batua"))) {
    return("UNIDAS PODEMOS - IU")
  }
  
  if (str_detect(partido_min,"vasc")) {
    return("PARTIDO NACIONALISTA VASCO")
  }
  
  if (str_detect(partido_min,c("psoe|partido socialista obrero español"))) {
    return("PARTIDO SOCIALISTA OBRERO ESPAÑOL")
  }
  
    if (str_detect(partido_min,c("pp|partido popular"))) {
    return("PARTIDO POPULAR")
    }
  
  if (str_detect(partido_min,c("bloque nacionalista galego"))) {
    return("BLOQUE NACIONALISTA GALLEGO")  
  }
  
  if (str_detect(partido_min,c("partido de la ciudadania"))) {
    return("CIUDADANOS")  
  }
  
  if (str_detect(partido_min,c("esquerra republicana de catalunya"))) { #Nótese que quedan aún partidos tipo coalición (considero que deberían incluirse)
    return("ESQUERRA REPUBLICANA DE CATALUNYA")  
  }
  
  if (any(partido_min == nombres_min)) {
    return(partido)  
  }
  
  return("OTRO")
}

cambia_nombres("PARTIT POPULAR-PARTIDO POPULAR", nombres_partidos) #ejemplo

#Aplicar función al dataframe
eleccion_tidy_filt <- eleccion_tidy |> rowwise() |> mutate(partido_n = cambia_nombres(partido, nombres_partidos))

#Reagrupar partido "otro"
eleccion_resumen <- eleccion_tidy_filt |>
  group_by(partido_n,anno,mes,codigo_ccaa,codigo_provincia,codigo_municipio,codigo_distrito_electoral) |> 
  mutate(votos_totales_partido = sum(votos)) |> 
  ungroup() # Ver anotaciones del cambio


```

```{r}
#write_csv(eleccion_resumen, file = "eleccion_resumen.csv") #Tarda un montón en cargar
```




---


## Encuestas

Debes descartar las encuestas que:

    -   se refieran a elecciones anteriores a 2008
    -   sean a pie de urna
    -   tamaño muestral desconocido o inferior a 500.
    -   tenga 1 día o menos de trabajo de campo.



```{r}
#| eval: false
head(surveys)
names(surveys)

surveys_tidy <- surveys |> 
  pivot_longer(cols = c(11:59), names_to = "partidos", values_to = "intencion_voto", values_drop_na = TRUE) |>
  drop_na(size) |>  
  filter(size >=500) |>   #tamaño muestral
  filter(date_elec >= "2008-01-01") |>  #elecciones desde 2008
  mutate(duracion_t_campo = field_date_to - field_date_from) |> 
  filter(duracion_t_campo > 1) |> #descartar enucentas con 1 días o menos de trabajo de campo
  filter(exit_poll == FALSE) |> 
  select(-exit_poll) #quitar var. a pie de urna porque no es informativa (sólo quedan las que no lo)

# names(surveys_tidy) <- c("tipo_encuesta", "fecha_elecciones", "id_entrevistador", "entrevistador", "media",
#                          "inicio_trabajo", "final_trabajo", "pie_urna", "n", "participacion_estimada",
#                          "intencion_voto", "duracion_t_campo")
# Por si resulta útil/cómodo más adelante


```




---




```{r}
# Tabla maestra que contiene nombres de municipios, sus códigos y las siglas de cada partido (para facilitar la visualización)

tabla_maestra <-
  eleccion_resumen |> 
  unite(col = "cod_poblacion", codigo_ccaa, codigo_provincia, codigo_municipio, sep = "-", remove = FALSE) |> 
  left_join(cod_mun, by =  c("cod_poblacion" = "cod_mun")) |> 
  mutate(siglas = case_when(
    
    partido_n == "PARTIDO SOCIALISTA OBRERO ESPAÑOL" ~ "PSOE",
    
    partido_n == "PARTIDO POPULAR" ~ "PP",
    
    partido_n == "CIUDADANOS" ~ "C's",
    
    partido_n == "BLOQUE NACIONALISTA GALLEGO" ~ "BNG",
    
    partido_n == "ESQUERRA REPUBLICANA DE CATALUNYA" ~ "ERC",
    
    partido_n == "UNIDAS PODEMOS - IU" ~ "PODEMOS-IU",
    
    partido_n == "EH - BILDU" ~ "EH-BILDU",
    
    partido_n == "PARTIDO NACIONALISTA VASCO" ~ "PNV",
    
    partido_n == "VOX" ~ "VOX",
    
    TRUE ~ "OTRO" ))

```




---




```{r}

datos_p1 <- tabla_maestra |> #Una fila por municipio
  filter(censo > 100000) |> #Condición del censo
  slice_max(votos_totales_partido, by = c(anno, mes, cod_poblacion)) |> #Partido más votado por elección
  distinct(anno, mes, municipio, cod_poblacion, siglas) |>  #Quito filas repetidas (partidos resultantes de la agrupación)
  group_by(anno, mes) |> 
  count(siglas) |> #Por elección cuento nº de veces qeu aparece el partido como más votado (=nº de municipios donde ganó) 
  ungroup() |> 
  mutate(
    siglas = factor(siglas, levels = unique(siglas)), # Aseguramos el orden
    eleccion = case_when(
      anno == 2008 ~ "2008",
      anno == 2011 ~ "2011",
      anno == 2015 ~ "2015",
      anno == 2016 ~ "2016",
      anno == 2019 & mes == "04" ~ 
      "2019 (abril)",
      anno == 2019 & mes == "11" ~ 
        "2019 (noviembre)"
    )
  )

  

```




---




```{r}
#| eval: FALSE

#Algunas comprobaciones
tabla_maestra |> 
  filter(censo > 100000) |> 
  slice_max(votos_totales_partido, by = c(anno, mes, cod_poblacion)) |> 
  distinct(anno, mes, municipio, cod_poblacion, partido_n, votos_totales_partido, votos_candidaturas) |> 
  count(municipio, cod_poblacion) |> 
  arrange(n)  #Hay dos municipios que no participaron en todas las elecciones

tabla_maestra |> 
  filter(censo > 100000) |> 
  slice_max(votos_totales_partido, by = c(anno, mes, cod_poblacion)) |> 
  distinct(anno, mes, municipio, cod_poblacion, partido_n, votos_totales_partido, votos_candidaturas) |> 
  filter(cod_poblacion %in% c("01-11-012", "01-41-038")) #Prece que Cádiz no estaba en 2016 ni las de 2019

tabla_maestra |> 
  filter(municipio == "Cádiz") |> 
  select(censo, anno, mes) |>
  filter(censo < 100000) |> 
  distinct(anno, mes) #En efecto ocurre eso

tabla_maestra |> 
  filter(municipio == "Dos Hermanas") |> 
  select(censo, anno, mes) |>
  filter(censo < 100000) |> 
  distinct(anno, mes) #Aquí no llegaban en 2008, 2011 ni 2015

```




# Primera pregunta

¿Qué partido fue el ganador en los municipios con más de 100.000 habitantes (censo) en cada una de las elecciones?



```{r}

colores_partidos <- c("OTRO" = "grey45", "PP" = "#17589d", "PNV" = "#308444", 
                      "PODEMOS-IU" = "#6b1f5f", "VOX" = "#5ac035", 
                      "PSOE" = "#c20e1a", "ERC" = "#fcc34e", "BNG" = "#76b3dd",
                      "C's" = "#fb5000")

ggplot(datos_p1, aes(fill = siglas, values = n)) +
  geom_waffle(n_rows = 10) +
  facet_grid(~eleccion) +
  scale_fill_manual(values = colores_partidos) +
  labs(title = "Partidos ganadores en municipios con >100.000 habitantes",
         fill = "Partido") +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    axis.text = element_blank(),
    strip.text = element_text(face = "bold",
                              size =9),
    plot.title = element_text(face = "bold",
                              hjust = 0.5,
                              margin = margin(b = 10)))

```


---


